<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>mavsim: /hsl/homes/jgoppert/Projects/mavsim/src/communication/AsyncSerial.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>/hsl/homes/jgoppert/Projects/mavsim/src/communication/AsyncSerial.cpp</h1>  </div>
</div>
<div class="contents">
<a href="_async_serial_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * File:   AsyncSerial.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> * Author: Terraneo Federico</span>
<a name="l00004"></a>00004 <span class="comment"> * Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00005"></a>00005 <span class="comment"> * Created on September 7, 2009, 10:46 AM</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> * v1.01: Fixed a bug that did not allow to reopen a closed serial port.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * v1.00: First release.</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * IMPORTANT:</span>
<a name="l00012"></a>00012 <span class="comment"> * On Mac OS X boost asio&#39;s serial ports have bugs, and the usual implementation</span>
<a name="l00013"></a>00013 <span class="comment"> * of this class does not work. So a workaround class was written temporarily,</span>
<a name="l00014"></a>00014 <span class="comment"> * until asio (hopefully) will fix Mac compatibility for serial ports.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * Please note that unlike said in the documentation on OS X until asio will</span>
<a name="l00017"></a>00017 <span class="comment"> * be fixed serial port *writes* are *not* asynchronous, but at least</span>
<a name="l00018"></a>00018 <span class="comment"> * asynchronous *read* works.</span>
<a name="l00019"></a>00019 <span class="comment"> * In addition the serial port open ignores the following options: parity,</span>
<a name="l00020"></a>00020 <span class="comment"> * character size, flow, stop bits, and defaults to 8N1 format.</span>
<a name="l00021"></a>00021 <span class="comment"> * I know it is bad but at least it&#39;s better than nothing.</span>
<a name="l00022"></a>00022 <span class="comment"> *</span>
<a name="l00023"></a>00023 <span class="comment"> */</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;<a class="code" href="_async_serial_8hpp.html">AsyncSerial.hpp</a>&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="keyword">using namespace </span>std;
<a name="l00033"></a>00033 <span class="keyword">using namespace </span>boost;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">//Class AsyncSerial</span>
<a name="l00037"></a>00037 <span class="comment">//</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#ifndef __APPLE__</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="class_async_serial_impl.html">00041</a> <span class="keyword">class </span><a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>: <span class="keyword">private</span> boost::noncopyable
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043 <span class="keyword">public</span>:
<a name="l00044"></a><a class="code" href="class_async_serial_impl.html#a6406760bb48feb68991ad75f3571af0d">00044</a>     <a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>(): io(), port(io), backgroundThread(), open(false),
<a name="l00045"></a>00045         error(false) {}
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="class_async_serial_impl.html#a5bcbca5696fb792b11f10e5052c81d5d">00047</a>     boost::asio::io_service io; 
<a name="l00048"></a><a class="code" href="class_async_serial_impl.html#aafb3eff806ecf80dc1b592e63621a5b7">00048</a>     boost::asio::serial_port port; 
<a name="l00049"></a><a class="code" href="class_async_serial_impl.html#a0c88ff57f3bdfb915c9465b34c81751d">00049</a>     boost::thread backgroundThread; 
<a name="l00050"></a><a class="code" href="class_async_serial_impl.html#aa5275eba924eaf58a61910419c6f5f08">00050</a>     <span class="keywordtype">bool</span> open; 
<a name="l00051"></a><a class="code" href="class_async_serial_impl.html#aa0e1bc182615e398614886874c030ce6">00051</a>     <span class="keywordtype">bool</span> error; 
<a name="l00052"></a><a class="code" href="class_async_serial_impl.html#abaaa8cda2e61d3af1e3ad60d8826e4da">00052</a>     <span class="keyword">mutable</span> boost::mutex errorMutex; 
<a name="l00053"></a>00053 
<a name="l00055"></a><a class="code" href="class_async_serial_impl.html#adaf78be7a01a111007653f9cb8e4e26f">00055</a>     std::vector&lt;char&gt; writeQueue;
<a name="l00056"></a><a class="code" href="class_async_serial_impl.html#a0f34c3180cd4fe7b35b3a7994500626c">00056</a>     boost::shared_array&lt;char&gt; writeBuffer; 
<a name="l00057"></a><a class="code" href="class_async_serial_impl.html#afdaf50158f55d7fad56a3891bf9c695e">00057</a>     <span class="keywordtype">size_t</span> writeBufferSize; 
<a name="l00058"></a><a class="code" href="class_async_serial_impl.html#aa09ba5bf286c2401bb674a6a871d6ea5">00058</a>     boost::mutex writeQueueMutex; 
<a name="l00059"></a><a class="code" href="class_async_serial_impl.html#a2ad0014ec0461e168f1a2e49428f7d09">00059</a>     <span class="keywordtype">char</span> readBuffer[<a class="code" href="class_async_serial.html#afa843216d519512f1f325a1b8849be26">AsyncSerial::readBufferSize</a>]; 
<a name="l00060"></a>00060 
<a name="l00062"></a><a class="code" href="class_async_serial_impl.html#a8e9e95f038b97d75dd0cfe34e8d5a7e7">00062</a>     boost::function&lt;void (const char*, size_t)&gt; callback;
<a name="l00063"></a>00063 };
<a name="l00064"></a>00064 
<a name="l00065"></a><a class="code" href="class_async_serial.html#aff78d677d0b72f9929448240313ca8f7">00065</a> <a class="code" href="class_async_serial.html#aff78d677d0b72f9929448240313ca8f7">AsyncSerial::AsyncSerial</a>(): pimpl(new <a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 }
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <a class="code" href="class_async_serial.html#aff78d677d0b72f9929448240313ca8f7">AsyncSerial::AsyncSerial</a>(<span class="keyword">const</span> std::string&amp; devname, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00071"></a>00071                          asio::serial_port_base::parity opt_parity,
<a name="l00072"></a>00072                          asio::serial_port_base::character_size opt_csize,
<a name="l00073"></a>00073                          asio::serial_port_base::flow_control opt_flow,
<a name="l00074"></a>00074                          asio::serial_port_base::stop_bits opt_stop)
<a name="l00075"></a>00075     : pimpl(new <a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>)
<a name="l00076"></a>00076 {
<a name="l00077"></a>00077     <a class="code" href="class_async_serial.html#ac703c6e3ee89e5821536ce7381a31238">open</a>(devname,baud_rate,opt_parity,opt_csize,opt_flow,opt_stop);
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#ac703c6e3ee89e5821536ce7381a31238">AsyncSerial::open</a>(<span class="keyword">const</span> std::string&amp; devname, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00081"></a>00081                        asio::serial_port_base::parity opt_parity,
<a name="l00082"></a>00082                        asio::serial_port_base::character_size opt_csize,
<a name="l00083"></a>00083                        asio::serial_port_base::flow_control opt_flow,
<a name="l00084"></a>00084                        asio::serial_port_base::stop_bits opt_stop)
<a name="l00085"></a>00085 {
<a name="l00086"></a>00086     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>()) <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">close</a>();
<a name="l00087"></a>00087 
<a name="l00088"></a>00088     <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);<span class="comment">//If an exception is thrown, error_ remains true</span>
<a name="l00089"></a>00089     pimpl-&gt;port.open(devname);
<a name="l00090"></a>00090     pimpl-&gt;port.set_option(asio::serial_port_base::baud_rate(baud_rate));
<a name="l00091"></a>00091     pimpl-&gt;port.set_option(opt_parity);
<a name="l00092"></a>00092     pimpl-&gt;port.set_option(opt_csize);
<a name="l00093"></a>00093     pimpl-&gt;port.set_option(opt_flow);
<a name="l00094"></a>00094     pimpl-&gt;port.set_option(opt_stop);
<a name="l00095"></a>00095 
<a name="l00096"></a>00096     <span class="comment">//This gives some work to the io_service before it is started</span>
<a name="l00097"></a>00097     pimpl-&gt;io.post(bind(&amp;AsyncSerial::doRead, <span class="keyword">this</span>));
<a name="l00098"></a>00098 
<a name="l00099"></a>00099     thread t(bind(&amp;asio::io_service::run, &amp;pimpl-&gt;io));
<a name="l00100"></a>00100     pimpl-&gt;backgroundThread.swap(t);
<a name="l00101"></a>00101     <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">false</span>);<span class="comment">//If we get here, no error</span>
<a name="l00102"></a>00102     pimpl-&gt;open=<span class="keyword">true</span>; <span class="comment">//Port is now open</span>
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a><a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">00105</a> <span class="keywordtype">bool</span> <a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">AsyncSerial::isOpen</a>()<span class="keyword"> const</span>
<a name="l00106"></a>00106 <span class="keyword"></span>{
<a name="l00107"></a>00107     <span class="keywordflow">return</span> pimpl-&gt;open;
<a name="l00108"></a>00108 }
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="class_async_serial.html#ace535bb4a10d7f3da995de77895076a5">00110</a> <span class="keywordtype">bool</span> <a class="code" href="class_async_serial.html#ace535bb4a10d7f3da995de77895076a5">AsyncSerial::errorStatus</a>()<span class="keyword"> const</span>
<a name="l00111"></a>00111 <span class="keyword"></span>{
<a name="l00112"></a>00112     lock_guard&lt;mutex&gt; l(pimpl-&gt;errorMutex);
<a name="l00113"></a>00113     <span class="keywordflow">return</span> pimpl-&gt;error;
<a name="l00114"></a>00114 }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">00116</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">AsyncSerial::close</a>()
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118     <span class="keywordflow">if</span> (!<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>()) <span class="keywordflow">return</span>;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     pimpl-&gt;open=<span class="keyword">false</span>;
<a name="l00121"></a>00121     pimpl-&gt;io.post(bind(&amp;AsyncSerial::doClose, <span class="keyword">this</span>));
<a name="l00122"></a>00122     pimpl-&gt;backgroundThread.join();
<a name="l00123"></a>00123     pimpl-&gt;io.reset();
<a name="l00124"></a>00124     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#ace535bb4a10d7f3da995de77895076a5">errorStatus</a>())
<a name="l00125"></a>00125     {
<a name="l00126"></a>00126         <span class="keywordflow">throw</span>(boost::system::system_error(boost::system::error_code(),
<a name="l00127"></a>00127                                           <span class="stringliteral">&quot;Error while closing the device&quot;</span>));
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129 }
<a name="l00130"></a>00130 
<a name="l00131"></a><a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">00131</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">AsyncSerial::write</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> size)
<a name="l00132"></a>00132 {
<a name="l00133"></a>00133     {
<a name="l00134"></a>00134         lock_guard&lt;mutex&gt; l(pimpl-&gt;writeQueueMutex);
<a name="l00135"></a>00135         pimpl-&gt;writeQueue.insert(pimpl-&gt;writeQueue.end(),data,data+size);
<a name="l00136"></a>00136     }
<a name="l00137"></a>00137     pimpl-&gt;io.post(bind(&amp;AsyncSerial::doWrite, <span class="keyword">this</span>));
<a name="l00138"></a>00138 }
<a name="l00139"></a>00139 
<a name="l00140"></a><a class="code" href="class_async_serial.html#a8f3665e55608b07fa9eb4e9d93b3ee95">00140</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">AsyncSerial::write</a>(<span class="keyword">const</span> std::vector&lt;char&gt;&amp; data)
<a name="l00141"></a>00141 {
<a name="l00142"></a>00142     {
<a name="l00143"></a>00143         lock_guard&lt;mutex&gt; l(pimpl-&gt;writeQueueMutex);
<a name="l00144"></a>00144         pimpl-&gt;writeQueue.insert(pimpl-&gt;writeQueue.end(),data.begin(),
<a name="l00145"></a>00145                                  data.end());
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147     pimpl-&gt;io.post(bind(&amp;AsyncSerial::doWrite, <span class="keyword">this</span>));
<a name="l00148"></a>00148 }
<a name="l00149"></a>00149 
<a name="l00150"></a><a class="code" href="class_async_serial.html#aa4285acd9b327cef013b0437cf188da7">00150</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#aa4285acd9b327cef013b0437cf188da7">AsyncSerial::writeString</a>(<span class="keyword">const</span> std::string&amp; s)
<a name="l00151"></a>00151 {
<a name="l00152"></a>00152     {
<a name="l00153"></a>00153         lock_guard&lt;mutex&gt; l(pimpl-&gt;writeQueueMutex);
<a name="l00154"></a>00154         pimpl-&gt;writeQueue.insert(pimpl-&gt;writeQueue.end(),s.begin(),s.end());
<a name="l00155"></a>00155     }
<a name="l00156"></a>00156     pimpl-&gt;io.post(bind(&amp;AsyncSerial::doWrite, <span class="keyword">this</span>));
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a><a class="code" href="class_async_serial.html#aac97fceec15171d8161bbc89b5b37474">00159</a> <a class="code" href="class_async_serial.html#aac97fceec15171d8161bbc89b5b37474">AsyncSerial::~AsyncSerial</a>()
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>())
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163         <span class="keywordflow">try</span>
<a name="l00164"></a>00164         {
<a name="l00165"></a>00165             <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">close</a>();
<a name="l00166"></a>00166         }
<a name="l00167"></a>00167         <span class="keywordflow">catch</span> (...)
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169             <span class="comment">//Don&#39;t throw from a destructor</span>
<a name="l00170"></a>00170         }
<a name="l00171"></a>00171     }
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keywordtype">void</span> AsyncSerial::doRead()
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176     pimpl-&gt;port.async_read_some(asio::buffer(pimpl-&gt;readBuffer,<a class="code" href="class_async_serial.html#afa843216d519512f1f325a1b8849be26">readBufferSize</a>),
<a name="l00177"></a>00177                                 bind(&amp;AsyncSerial::readEnd,
<a name="l00178"></a>00178                                      <span class="keyword">this</span>,
<a name="l00179"></a>00179                                      asio::placeholders::error,
<a name="l00180"></a>00180                                      asio::placeholders::bytes_transferred));
<a name="l00181"></a>00181 }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="keywordtype">void</span> AsyncSerial::readEnd(<span class="keyword">const</span> boost::system::error_code&amp; error,
<a name="l00184"></a>00184                           <span class="keywordtype">size_t</span> bytes_transferred)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186     <span class="keywordflow">if</span> (error)
<a name="l00187"></a>00187     {
<a name="l00188"></a>00188 <span class="preprocessor">#ifdef __APPLE__</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (error.value()==45)
<a name="l00190"></a>00190         {
<a name="l00191"></a>00191             <span class="comment">//Bug on OS X, it might be necessary to repeat the setup</span>
<a name="l00192"></a>00192             <span class="comment">//http://osdir.com/ml/lib.boost.asio.user/2008-08/msg00004.html</span>
<a name="l00193"></a>00193             doRead();
<a name="l00194"></a>00194             <span class="keywordflow">return</span>;
<a name="l00195"></a>00195         }
<a name="l00196"></a>00196 <span class="preprocessor">#endif //__APPLE__</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>        <span class="comment">//error can be true even because the serial port was closed.</span>
<a name="l00198"></a>00198         <span class="comment">//In this case it is not a real error, so ignore</span>
<a name="l00199"></a>00199         <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>())
<a name="l00200"></a>00200         {
<a name="l00201"></a>00201             doClose();
<a name="l00202"></a>00202             <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00203"></a>00203         }
<a name="l00204"></a>00204     }
<a name="l00205"></a>00205     <span class="keywordflow">else</span>
<a name="l00206"></a>00206     {
<a name="l00207"></a>00207         <span class="keywordflow">if</span> (pimpl-&gt;callback) pimpl-&gt;callback(pimpl-&gt;readBuffer,
<a name="l00208"></a>00208                                                  bytes_transferred);
<a name="l00209"></a>00209         doRead();
<a name="l00210"></a>00210     }
<a name="l00211"></a>00211 }
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="keywordtype">void</span> AsyncSerial::doWrite()
<a name="l00214"></a>00214 {
<a name="l00215"></a>00215     <span class="comment">//If a write operation is already in progress, do nothing</span>
<a name="l00216"></a>00216     <span class="keywordflow">if</span> (pimpl-&gt;writeBuffer==0)
<a name="l00217"></a>00217     {
<a name="l00218"></a>00218         lock_guard&lt;mutex&gt; l(pimpl-&gt;writeQueueMutex);
<a name="l00219"></a>00219         pimpl-&gt;writeBufferSize=pimpl-&gt;writeQueue.size();
<a name="l00220"></a>00220         pimpl-&gt;writeBuffer.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[pimpl-&gt;writeQueue.size()]);
<a name="l00221"></a>00221         copy(pimpl-&gt;writeQueue.begin(),pimpl-&gt;writeQueue.end(),
<a name="l00222"></a>00222              pimpl-&gt;writeBuffer.get());
<a name="l00223"></a>00223         pimpl-&gt;writeQueue.clear();
<a name="l00224"></a>00224         async_write(pimpl-&gt;port,asio::buffer(pimpl-&gt;writeBuffer.get(),
<a name="l00225"></a>00225                                              pimpl-&gt;writeBufferSize),
<a name="l00226"></a>00226                     bind(&amp;AsyncSerial::writeEnd, <span class="keyword">this</span>, asio::placeholders::error));
<a name="l00227"></a>00227     }
<a name="l00228"></a>00228 }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230 <span class="keywordtype">void</span> AsyncSerial::writeEnd(<span class="keyword">const</span> boost::system::error_code&amp; error)
<a name="l00231"></a>00231 {
<a name="l00232"></a>00232     <span class="keywordflow">if</span> (!error)
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234         lock_guard&lt;mutex&gt; l(pimpl-&gt;writeQueueMutex);
<a name="l00235"></a>00235         <span class="keywordflow">if</span> (pimpl-&gt;writeQueue.empty())
<a name="l00236"></a>00236         {
<a name="l00237"></a>00237             pimpl-&gt;writeBuffer.reset();
<a name="l00238"></a>00238             pimpl-&gt;writeBufferSize=0;
<a name="l00239"></a>00239 
<a name="l00240"></a>00240             <span class="keywordflow">return</span>;
<a name="l00241"></a>00241         }
<a name="l00242"></a>00242         pimpl-&gt;writeBufferSize=pimpl-&gt;writeQueue.size();
<a name="l00243"></a>00243         pimpl-&gt;writeBuffer.reset(<span class="keyword">new</span> <span class="keywordtype">char</span>[pimpl-&gt;writeQueue.size()]);
<a name="l00244"></a>00244         copy(pimpl-&gt;writeQueue.begin(),pimpl-&gt;writeQueue.end(),
<a name="l00245"></a>00245              pimpl-&gt;writeBuffer.get());
<a name="l00246"></a>00246         pimpl-&gt;writeQueue.clear();
<a name="l00247"></a>00247         async_write(pimpl-&gt;port,asio::buffer(pimpl-&gt;writeBuffer.get(),
<a name="l00248"></a>00248                                              pimpl-&gt;writeBufferSize),
<a name="l00249"></a>00249                     bind(&amp;AsyncSerial::writeEnd, <span class="keyword">this</span>, asio::placeholders::error));
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     <span class="keywordflow">else</span>
<a name="l00252"></a>00252     {
<a name="l00253"></a>00253         <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00254"></a>00254         doClose();
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256 }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 <span class="keywordtype">void</span> AsyncSerial::doClose()
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     boost::system::error_code ec;
<a name="l00261"></a>00261     pimpl-&gt;port.cancel(ec);
<a name="l00262"></a>00262     <span class="keywordflow">if</span> (ec) <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00263"></a>00263     pimpl-&gt;port.close(ec);
<a name="l00264"></a>00264     <span class="keywordflow">if</span> (ec) <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 
<a name="l00267"></a><a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">00267</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">AsyncSerial::setErrorStatus</a>(<span class="keywordtype">bool</span> e)
<a name="l00268"></a>00268 {
<a name="l00269"></a>00269     lock_guard&lt;mutex&gt; l(pimpl-&gt;errorMutex);
<a name="l00270"></a>00270     pimpl-&gt;error=e;
<a name="l00271"></a>00271 }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5e3353b69535c8eb14e018070efaf3c3">AsyncSerial::setReadCallback</a>(<span class="keyword">const</span>
<a name="l00274"></a>00274                                   function&lt;<span class="keywordtype">void</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">size_t</span>)&gt;&amp; callback)
<a name="l00275"></a>00275 {
<a name="l00276"></a>00276     pimpl-&gt;callback=callback;
<a name="l00277"></a>00277 }
<a name="l00278"></a>00278 
<a name="l00279"></a><a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">00279</a> <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">AsyncSerial::clearReadCallback</a>()
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281     pimpl-&gt;callback.clear();
<a name="l00282"></a>00282 }
<a name="l00283"></a>00283 
<a name="l00284"></a>00284 <span class="preprocessor">#else //__APPLE__</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span>
<a name="l00286"></a>00286 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00287"></a>00287 <span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<a name="l00288"></a>00288 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
<a name="l00289"></a>00289 <span class="preprocessor">#include &lt;termios.h&gt;</span>
<a name="l00290"></a>00290 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="keyword">class </span><a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>: <span class="keyword">private</span> boost::noncopyable
<a name="l00293"></a>00293 {
<a name="l00294"></a>00294 <span class="keyword">public</span>:
<a name="l00295"></a>00295     <a class="code" href="class_async_serial_impl.html#a6406760bb48feb68991ad75f3571af0d">AsyncSerialImpl</a>(): <a class="code" href="class_async_serial_impl.html#a0c88ff57f3bdfb915c9465b34c81751d" title="Thread that runs read/write operations.">backgroundThread</a>(), <a class="code" href="class_async_serial_impl.html#aa5275eba924eaf58a61910419c6f5f08" title="True if port open.">open</a>(false), error(false) {}
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     boost::thread <a class="code" href="class_async_serial_impl.html#a0c88ff57f3bdfb915c9465b34c81751d" title="Thread that runs read/write operations.">backgroundThread</a>; 
<a name="l00298"></a>00298     <span class="keywordtype">bool</span> <a class="code" href="class_async_serial_impl.html#aa5275eba924eaf58a61910419c6f5f08" title="True if port open.">open</a>; 
<a name="l00299"></a>00299     <span class="keywordtype">bool</span> error; 
<a name="l00300"></a>00300     <span class="keyword">mutable</span> boost::mutex <a class="code" href="class_async_serial_impl.html#abaaa8cda2e61d3af1e3ad60d8826e4da" title="Mutex for access to error.">errorMutex</a>; 
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     <span class="keywordtype">int</span> fd; 
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     <span class="keywordtype">char</span> <a class="code" href="class_async_serial_impl.html#a2ad0014ec0461e168f1a2e49428f7d09" title="data being read">readBuffer</a>[<a class="code" href="class_async_serial.html#afa843216d519512f1f325a1b8849be26">AsyncSerial::readBufferSize</a>]; 
<a name="l00305"></a>00305 
<a name="l00307"></a>00307     boost::function&lt;void (const char*, size_t)&gt; <a class="code" href="class_async_serial_impl.html#a8e9e95f038b97d75dd0cfe34e8d5a7e7" title="Read complete callback.">callback</a>;
<a name="l00308"></a>00308 };
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <a class="code" href="class_async_serial.html#aff78d677d0b72f9929448240313ca8f7">AsyncSerial::AsyncSerial</a>(): pimpl(new <a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>)
<a name="l00311"></a>00311 {
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315 <a class="code" href="class_async_serial.html#aff78d677d0b72f9929448240313ca8f7">AsyncSerial::AsyncSerial</a>(<span class="keyword">const</span> std::string&amp; devname, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00316"></a>00316                          asio::serial_port_base::parity opt_parity,
<a name="l00317"></a>00317                          asio::serial_port_base::character_size opt_csize,
<a name="l00318"></a>00318                          asio::serial_port_base::flow_control opt_flow,
<a name="l00319"></a>00319                          asio::serial_port_base::stop_bits opt_stop)
<a name="l00320"></a>00320     : pimpl(new <a class="code" href="class_async_serial_impl.html">AsyncSerialImpl</a>)
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322     <a class="code" href="class_async_serial.html#ac703c6e3ee89e5821536ce7381a31238">open</a>(devname,baud_rate,opt_parity,opt_csize,opt_flow,opt_stop);
<a name="l00323"></a>00323 }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#ac703c6e3ee89e5821536ce7381a31238">AsyncSerial::open</a>(<span class="keyword">const</span> std::string&amp; devname, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00326"></a>00326                        asio::serial_port_base::parity opt_parity,
<a name="l00327"></a>00327                        asio::serial_port_base::character_size opt_csize,
<a name="l00328"></a>00328                        asio::serial_port_base::flow_control opt_flow,
<a name="l00329"></a>00329                        asio::serial_port_base::stop_bits opt_stop)
<a name="l00330"></a>00330 {
<a name="l00331"></a>00331     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>()) <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">close</a>();
<a name="l00332"></a>00332 
<a name="l00333"></a>00333     <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);<span class="comment">//If an exception is thrown, error remains true</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="keyword">struct </span>termios new_attributes;
<a name="l00336"></a>00336     speed_t speed;
<a name="l00337"></a>00337     <span class="keywordtype">int</span> status;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339     <span class="comment">// Open port</span>
<a name="l00340"></a>00340     pimpl-&gt;fd=<a class="code" href="class_async_serial.html#ac703c6e3ee89e5821536ce7381a31238">::open</a>(devname.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
<a name="l00341"></a>00341     <span class="keywordflow">if</span> (pimpl-&gt;fd&lt;0) <span class="keywordflow">throw</span>(boost::system::system_error(
<a name="l00342"></a>00342                                    boost::system::error_code(),<span class="stringliteral">&quot;Failed to open port&quot;</span>));
<a name="l00343"></a>00343 
<a name="l00344"></a>00344     <span class="comment">// Set Port parameters.</span>
<a name="l00345"></a>00345     status=tcgetattr(pimpl-&gt;fd,&amp;new_attributes);
<a name="l00346"></a>00346     <span class="keywordflow">if</span> (status&lt;0  || !isatty(pimpl-&gt;fd))
<a name="l00347"></a>00347     {<a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653"></a>
<a name="l00348"></a>00348 <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">        ::close</a>(pimpl-&gt;fd);
<a name="l00349"></a>00349         <span class="keywordflow">throw</span>(boost::system::system_error(
<a name="l00350"></a>00350                   boost::system::error_code(),<span class="stringliteral">&quot;Device is not a tty&quot;</span>));
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352     new_attributes.c_iflag = IGNBRK;
<a name="l00353"></a>00353     new_attributes.c_oflag = 0;
<a name="l00354"></a>00354     new_attributes.c_lflag = 0;
<a name="l00355"></a>00355     new_attributes.c_cflag = (CS8 | CREAD | CLOCAL);<span class="comment">//8 data bit,Enable receiver,Ignore modem</span>
<a name="l00356"></a>00356     <span class="comment">/* In non canonical mode (Ctrl-C and other disabled, no echo,...) VMIN and VTIME work this way:</span>
<a name="l00357"></a>00357 <span class="comment">    if the function read() has&#39;nt read at least VMIN chars it waits until has read at least VMIN</span>
<a name="l00358"></a>00358 <span class="comment">    chars (even if VTIME timeout expires); once it has read at least vmin chars, if subsequent</span>
<a name="l00359"></a>00359 <span class="comment">    chars do not arrive before VTIME expires, it returns error; if a char arrives, it resets the</span>
<a name="l00360"></a>00360 <span class="comment">    timeout, so the internal timer will again start from zero (for the nex char,if any)*/</span>
<a name="l00361"></a>00361     new_attributes.c_cc[VMIN]=1;<span class="comment">// Minimum number of characters to read before returning error</span>
<a name="l00362"></a>00362     new_attributes.c_cc[VTIME]=1;<span class="comment">// Set timeouts in tenths of second</span>
<a name="l00363"></a>00363 
<a name="l00364"></a>00364     <span class="comment">// Set baud rate</span>
<a name="l00365"></a>00365     <span class="keywordflow">switch</span> (baud_rate)
<a name="l00366"></a>00366     {
<a name="l00367"></a>00367     <span class="keywordflow">case</span> 50:
<a name="l00368"></a>00368         speed= B50;
<a name="l00369"></a>00369         <span class="keywordflow">break</span>;
<a name="l00370"></a>00370     <span class="keywordflow">case</span> 75:
<a name="l00371"></a>00371         speed= B75;
<a name="l00372"></a>00372         <span class="keywordflow">break</span>;
<a name="l00373"></a>00373     <span class="keywordflow">case</span> 110:
<a name="l00374"></a>00374         speed= B110;
<a name="l00375"></a>00375         <span class="keywordflow">break</span>;
<a name="l00376"></a>00376     <span class="keywordflow">case</span> 134:
<a name="l00377"></a>00377         speed= B134;
<a name="l00378"></a>00378         <span class="keywordflow">break</span>;
<a name="l00379"></a>00379     <span class="keywordflow">case</span> 150:
<a name="l00380"></a>00380         speed= B150;
<a name="l00381"></a>00381         <span class="keywordflow">break</span>;
<a name="l00382"></a>00382     <span class="keywordflow">case</span> 200:
<a name="l00383"></a>00383         speed= B200;
<a name="l00384"></a>00384         <span class="keywordflow">break</span>;
<a name="l00385"></a>00385     <span class="keywordflow">case</span> 300:
<a name="l00386"></a>00386         speed= B300;
<a name="l00387"></a>00387         <span class="keywordflow">break</span>;
<a name="l00388"></a>00388     <span class="keywordflow">case</span> 600:
<a name="l00389"></a>00389         speed= B600;
<a name="l00390"></a>00390         <span class="keywordflow">break</span>;
<a name="l00391"></a>00391     <span class="keywordflow">case</span> 1200:
<a name="l00392"></a>00392         speed= B1200;
<a name="l00393"></a>00393         <span class="keywordflow">break</span>;
<a name="l00394"></a>00394     <span class="keywordflow">case</span> 1800:
<a name="l00395"></a>00395         speed= B1800;
<a name="l00396"></a>00396         <span class="keywordflow">break</span>;
<a name="l00397"></a>00397     <span class="keywordflow">case</span> 2400:
<a name="l00398"></a>00398         speed= B2400;
<a name="l00399"></a>00399         <span class="keywordflow">break</span>;
<a name="l00400"></a>00400     <span class="keywordflow">case</span> 4800:
<a name="l00401"></a>00401         speed= B4800;
<a name="l00402"></a>00402         <span class="keywordflow">break</span>;
<a name="l00403"></a>00403     <span class="keywordflow">case</span> 9600:
<a name="l00404"></a>00404         speed= B9600;
<a name="l00405"></a>00405         <span class="keywordflow">break</span>;
<a name="l00406"></a>00406     <span class="keywordflow">case</span> 19200:
<a name="l00407"></a>00407         speed= B19200;
<a name="l00408"></a>00408         <span class="keywordflow">break</span>;
<a name="l00409"></a>00409     <span class="keywordflow">case</span> 38400:
<a name="l00410"></a>00410         speed= B38400;
<a name="l00411"></a>00411         <span class="keywordflow">break</span>;
<a name="l00412"></a>00412     <span class="keywordflow">case</span> 57600:
<a name="l00413"></a>00413         speed= B57600;
<a name="l00414"></a>00414         <span class="keywordflow">break</span>;
<a name="l00415"></a>00415     <span class="keywordflow">case</span> 115200:
<a name="l00416"></a>00416         speed= B115200;
<a name="l00417"></a>00417         <span class="keywordflow">break</span>;
<a name="l00418"></a>00418     <span class="keywordflow">case</span> 230400:
<a name="l00419"></a>00419         speed= B230400;
<a name="l00420"></a>00420         <span class="keywordflow">break</span>;
<a name="l00421"></a>00421     <span class="keywordflow">default</span>:
<a name="l00422"></a>00422     {<a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653"></a>
<a name="l00423"></a>00423 <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">        ::close</a>(pimpl-&gt;fd);
<a name="l00424"></a>00424         <span class="keywordflow">throw</span>(boost::system::system_error(
<a name="l00425"></a>00425                   boost::system::error_code(),<span class="stringliteral">&quot;Unsupported baud rate&quot;</span>));
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427     }
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     cfsetospeed(&amp;new_attributes,speed);
<a name="l00430"></a>00430     cfsetispeed(&amp;new_attributes,speed);
<a name="l00431"></a>00431 
<a name="l00432"></a>00432     <span class="comment">//Make changes effective</span>
<a name="l00433"></a>00433     status=tcsetattr(pimpl-&gt;fd, TCSANOW, &amp;new_attributes);
<a name="l00434"></a>00434     <span class="keywordflow">if</span> (status&lt;0)
<a name="l00435"></a>00435     {<a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653"></a>
<a name="l00436"></a>00436 <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">        ::close</a>(pimpl-&gt;fd);
<a name="l00437"></a>00437         <span class="keywordflow">throw</span>(boost::system::system_error(
<a name="l00438"></a>00438                   boost::system::error_code(),<span class="stringliteral">&quot;Can&#39;t set port attributes&quot;</span>));
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440 
<a name="l00441"></a>00441     <span class="comment">//These 3 lines clear the O_NONBLOCK flag</span>
<a name="l00442"></a>00442     status=fcntl(pimpl-&gt;fd, F_GETFL, 0);
<a name="l00443"></a>00443     <span class="keywordflow">if</span> (status!=-1) fcntl(pimpl-&gt;fd, F_SETFL, status &amp; ~O_NONBLOCK);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">false</span>);<span class="comment">//If we get here, no error</span>
<a name="l00446"></a>00446     pimpl-&gt;open=<span class="keyword">true</span>; <span class="comment">//Port is now open</span>
<a name="l00447"></a>00447 
<a name="l00448"></a>00448     thread t(bind(&amp;AsyncSerial::doRead, <span class="keyword">this</span>));
<a name="l00449"></a>00449     pimpl-&gt;backgroundThread.swap(t);
<a name="l00450"></a>00450 }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="keywordtype">bool</span> <a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">AsyncSerial::isOpen</a>()<span class="keyword"> const</span>
<a name="l00453"></a>00453 <span class="keyword"></span>{
<a name="l00454"></a>00454     <span class="keywordflow">return</span> pimpl-&gt;open;
<a name="l00455"></a>00455 }
<a name="l00456"></a>00456 
<a name="l00457"></a>00457 <span class="keywordtype">bool</span> <a class="code" href="class_async_serial.html#ace535bb4a10d7f3da995de77895076a5">AsyncSerial::errorStatus</a>()<span class="keyword"> const</span>
<a name="l00458"></a>00458 <span class="keyword"></span>{
<a name="l00459"></a>00459     lock_guard&lt;mutex&gt; l(pimpl-&gt;errorMutex);
<a name="l00460"></a>00460     <span class="keywordflow">return</span> pimpl-&gt;error;
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">AsyncSerial::close</a>()
<a name="l00464"></a>00464 {
<a name="l00465"></a>00465     <span class="keywordflow">if</span> (!<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>()) <span class="keywordflow">return</span>;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467     pimpl-&gt;open=<span class="keyword">false</span>;<a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653"></a>
<a name="l00468"></a>00468 <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653"></a>
<a name="l00469"></a>00469 <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">    ::close</a>(pimpl-&gt;fd); <span class="comment">//The thread waiting on I/O should return</span>
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     pimpl-&gt;backgroundThread.join();
<a name="l00472"></a>00472     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#ace535bb4a10d7f3da995de77895076a5">errorStatus</a>())
<a name="l00473"></a>00473     {
<a name="l00474"></a>00474         <span class="keywordflow">throw</span>(boost::system::system_error(boost::system::error_code(),
<a name="l00475"></a>00475                                           <span class="stringliteral">&quot;Error while closing the device&quot;</span>));
<a name="l00476"></a>00476     }
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">AsyncSerial::write</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> size)
<a name="l00480"></a>00480 {
<a name="l00481"></a>00481     <span class="keywordflow">if</span> (::<a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">write</a>(pimpl-&gt;fd,data,size)!=size) <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00482"></a>00482 }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">AsyncSerial::write</a>(<span class="keyword">const</span> std::vector&lt;char&gt;&amp; data)
<a name="l00485"></a>00485 {
<a name="l00486"></a>00486     <span class="keywordflow">if</span> (::<a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">write</a>(pimpl-&gt;fd,&amp;data[0],data.size())!=data.size())
<a name="l00487"></a>00487         <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00488"></a>00488 }
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#aa4285acd9b327cef013b0437cf188da7">AsyncSerial::writeString</a>(<span class="keyword">const</span> std::string&amp; s)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492     <span class="keywordflow">if</span> (::<a class="code" href="class_async_serial.html#a5a7e4aa37924e593ba7636be0be0bf0a">write</a>(pimpl-&gt;fd,&amp;s[0],s.size())!=s.size()) <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00493"></a>00493 }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <a class="code" href="class_async_serial.html#aac97fceec15171d8161bbc89b5b37474">AsyncSerial::~AsyncSerial</a>()
<a name="l00496"></a>00496 {
<a name="l00497"></a>00497     <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>())
<a name="l00498"></a>00498     {
<a name="l00499"></a>00499         <span class="keywordflow">try</span>
<a name="l00500"></a>00500         {
<a name="l00501"></a>00501             <a class="code" href="class_async_serial.html#a5cf2bac916cb71ec14b3fa35c2de7653">close</a>();
<a name="l00502"></a>00502         }
<a name="l00503"></a>00503         <span class="keywordflow">catch</span> (...)
<a name="l00504"></a>00504         {
<a name="l00505"></a>00505             <span class="comment">//Don&#39;t throw from a destructor</span>
<a name="l00506"></a>00506         }
<a name="l00507"></a>00507     }
<a name="l00508"></a>00508 }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="keywordtype">void</span> AsyncSerial::doRead()
<a name="l00511"></a>00511 {
<a name="l00512"></a>00512     <span class="comment">//Read loop in spawned thread</span>
<a name="l00513"></a>00513     <span class="keywordflow">for</span> (;;)
<a name="l00514"></a>00514     {
<a name="l00515"></a>00515         <span class="keywordtype">int</span> received=::read(pimpl-&gt;fd,pimpl-&gt;readBuffer,<a class="code" href="class_async_serial.html#afa843216d519512f1f325a1b8849be26">readBufferSize</a>);
<a name="l00516"></a>00516         <span class="keywordflow">if</span> (received&lt;0)
<a name="l00517"></a>00517         {
<a name="l00518"></a>00518             <span class="keywordflow">if</span> (<a class="code" href="class_async_serial.html#aaf820dc7365e66945c543b6023b7ce4f">isOpen</a>()==<span class="keyword">false</span>) <span class="keywordflow">return</span>; <span class="comment">//Thread interrupted because port closed</span>
<a name="l00519"></a>00519             <span class="keywordflow">else</span>
<a name="l00520"></a>00520             {
<a name="l00521"></a>00521                 <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">setErrorStatus</a>(<span class="keyword">true</span>);
<a name="l00522"></a>00522                 <span class="keywordflow">continue</span>;
<a name="l00523"></a>00523             }
<a name="l00524"></a>00524         }
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (pimpl-&gt;callback) pimpl-&gt;callback(pimpl-&gt;readBuffer, received);
<a name="l00526"></a>00526     }
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="keywordtype">void</span> AsyncSerial::readEnd(<span class="keyword">const</span> boost::system::error_code&amp; error,
<a name="l00530"></a>00530                           <span class="keywordtype">size_t</span> bytes_transferred)
<a name="l00531"></a>00531 {
<a name="l00532"></a>00532     <span class="comment">//Not used</span>
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 <span class="keywordtype">void</span> AsyncSerial::doWrite()
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537     <span class="comment">//Not used</span>
<a name="l00538"></a>00538 }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540 <span class="keywordtype">void</span> AsyncSerial::writeEnd(<span class="keyword">const</span> boost::system::error_code&amp; error)
<a name="l00541"></a>00541 {
<a name="l00542"></a>00542     <span class="comment">//Not used</span>
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="keywordtype">void</span> AsyncSerial::doClose()
<a name="l00546"></a>00546 {
<a name="l00547"></a>00547     <span class="comment">//Not used</span>
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#afb60a8e6ae2469094fe11d52e4336648">AsyncSerial::setErrorStatus</a>(<span class="keywordtype">bool</span> e)
<a name="l00551"></a>00551 {
<a name="l00552"></a>00552     lock_guard&lt;mutex&gt; l(pimpl-&gt;errorMutex);
<a name="l00553"></a>00553     pimpl-&gt;error=e;
<a name="l00554"></a>00554 }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a5e3353b69535c8eb14e018070efaf3c3">AsyncSerial::setReadCallback</a>(<span class="keyword">const</span>
<a name="l00557"></a>00557                                   function&lt;<span class="keywordtype">void</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">size_t</span>)&gt;&amp; callback)
<a name="l00558"></a>00558 {
<a name="l00559"></a>00559     pimpl-&gt;callback=callback;
<a name="l00560"></a>00560 }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="keywordtype">void</span> <a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">AsyncSerial::clearReadCallback</a>()
<a name="l00563"></a>00563 {
<a name="l00564"></a>00564     pimpl-&gt;callback.clear();
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="preprocessor">#endif //__APPLE__</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span>
<a name="l00569"></a>00569 <span class="comment">//</span>
<a name="l00570"></a>00570 <span class="comment">//Class CallbackAsyncSerial</span>
<a name="l00571"></a>00571 <span class="comment">//</span>
<a name="l00572"></a>00572 
<a name="l00573"></a><a class="code" href="class_callback_async_serial.html#a5a836a464120c216ebe1a87e2ef0f741">00573</a> <a class="code" href="class_callback_async_serial.html#a5a836a464120c216ebe1a87e2ef0f741">CallbackAsyncSerial::CallbackAsyncSerial</a>(): <a class="code" href="class_async_serial.html">AsyncSerial</a>()
<a name="l00574"></a>00574 {
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <a class="code" href="class_callback_async_serial.html#a5a836a464120c216ebe1a87e2ef0f741">CallbackAsyncSerial::CallbackAsyncSerial</a>(<span class="keyword">const</span> std::string&amp; devname,
<a name="l00579"></a>00579         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00580"></a>00580         asio::serial_port_base::parity opt_parity,
<a name="l00581"></a>00581         asio::serial_port_base::character_size opt_csize,
<a name="l00582"></a>00582         asio::serial_port_base::flow_control opt_flow,
<a name="l00583"></a>00583         asio::serial_port_base::stop_bits opt_stop)
<a name="l00584"></a>00584     :<a class="code" href="class_async_serial.html">AsyncSerial</a>(devname,baud_rate,opt_parity,opt_csize,opt_flow,opt_stop)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 }
<a name="l00588"></a>00588 
<a name="l00589"></a>00589 <span class="keywordtype">void</span> <a class="code" href="class_callback_async_serial.html#acc765496552eb30cafcb4f25e93a003f">CallbackAsyncSerial::setCallback</a>(<span class="keyword">const</span>
<a name="l00590"></a>00590                                       function&lt;<span class="keywordtype">void</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keywordtype">size_t</span>)&gt;&amp; callback)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592     <a class="code" href="class_async_serial.html#a5e3353b69535c8eb14e018070efaf3c3">setReadCallback</a>(callback);
<a name="l00593"></a>00593 }
<a name="l00594"></a>00594 
<a name="l00595"></a><a class="code" href="class_callback_async_serial.html#ae24b2b4bc197b66b889d1d654f3a523c">00595</a> <span class="keywordtype">void</span> <a class="code" href="class_callback_async_serial.html#ae24b2b4bc197b66b889d1d654f3a523c">CallbackAsyncSerial::clearCallback</a>()
<a name="l00596"></a>00596 {
<a name="l00597"></a>00597     <a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">clearReadCallback</a>();
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 
<a name="l00600"></a><a class="code" href="class_callback_async_serial.html#a9b575d0fece1a9889edf25b874af504e">00600</a> <a class="code" href="class_callback_async_serial.html#a9b575d0fece1a9889edf25b874af504e">CallbackAsyncSerial::~CallbackAsyncSerial</a>()
<a name="l00601"></a>00601 {
<a name="l00602"></a>00602     <a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">clearReadCallback</a>();
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 <span class="comment">//</span>
<a name="l00606"></a>00606 <span class="comment">//Class BufferedAsyncSerial</span>
<a name="l00607"></a>00607 <span class="comment">//</span>
<a name="l00608"></a>00608 
<a name="l00609"></a><a class="code" href="class_buffered_async_serial.html#a6f8045e40a5b9e96f3474b29c00cf6ec">00609</a> <a class="code" href="class_buffered_async_serial.html#a6f8045e40a5b9e96f3474b29c00cf6ec">BufferedAsyncSerial::BufferedAsyncSerial</a>(): <a class="code" href="class_async_serial.html">AsyncSerial</a>()
<a name="l00610"></a>00610 {
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a><a class="code" href="class_buffered_async_serial.html#ac2265bdc6e90d4f9f294f1a4c879f08f">00614</a> <span class="keywordtype">int</span> <a class="code" href="class_buffered_async_serial.html#ac2265bdc6e90d4f9f294f1a4c879f08f">BufferedAsyncSerial::available</a>()
<a name="l00615"></a>00615 {
<a name="l00616"></a>00616     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00617"></a>00617     <span class="keywordflow">return</span> readQueue.size();
<a name="l00618"></a>00618 }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <a class="code" href="class_buffered_async_serial.html#a6f8045e40a5b9e96f3474b29c00cf6ec">BufferedAsyncSerial::BufferedAsyncSerial</a>(<span class="keyword">const</span> std::string&amp; devname,
<a name="l00621"></a>00621         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> baud_rate,
<a name="l00622"></a>00622         asio::serial_port_base::parity opt_parity,
<a name="l00623"></a>00623         asio::serial_port_base::character_size opt_csize,
<a name="l00624"></a>00624         asio::serial_port_base::flow_control opt_flow,
<a name="l00625"></a>00625         asio::serial_port_base::stop_bits opt_stop)
<a name="l00626"></a>00626     :<a class="code" href="class_async_serial.html">AsyncSerial</a>(devname,baud_rate,opt_parity,opt_csize,opt_flow,opt_stop)
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628     <a class="code" href="class_async_serial.html#a5e3353b69535c8eb14e018070efaf3c3">setReadCallback</a>(bind(&amp;BufferedAsyncSerial::readCallback, <span class="keyword">this</span>, _1, _2));
<a name="l00629"></a>00629 }
<a name="l00630"></a>00630 
<a name="l00631"></a><a class="code" href="class_buffered_async_serial.html#ad5ee3fa826eb9a5d8e48f0c27149bfda">00631</a> <span class="keywordtype">size_t</span> <a class="code" href="class_buffered_async_serial.html#ace6bba84ff120bcf28ebd0dec49db9a3">BufferedAsyncSerial::read</a>(<span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> size)
<a name="l00632"></a>00632 {
<a name="l00633"></a>00633     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00634"></a>00634     <span class="keywordtype">size_t</span> result=<a class="code" href="scicos__block4_8h.html#ac6afabdc09a49a433ee19d8a9486056d">min</a>(size,readQueue.size());
<a name="l00635"></a>00635     vector&lt;char&gt;::iterator it=readQueue.begin()+result;
<a name="l00636"></a>00636     copy(readQueue.begin(),it,data);
<a name="l00637"></a>00637     readQueue.erase(readQueue.begin(),it);
<a name="l00638"></a>00638     <span class="keywordflow">return</span> result;
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 
<a name="l00641"></a><a class="code" href="class_buffered_async_serial.html#ace6bba84ff120bcf28ebd0dec49db9a3">00641</a> std::vector&lt;char&gt; <a class="code" href="class_buffered_async_serial.html#ace6bba84ff120bcf28ebd0dec49db9a3">BufferedAsyncSerial::read</a>()
<a name="l00642"></a>00642 {
<a name="l00643"></a>00643     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00644"></a>00644     vector&lt;char&gt; result;
<a name="l00645"></a>00645     result.swap(readQueue);
<a name="l00646"></a>00646     <span class="keywordflow">return</span> result;
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a><a class="code" href="class_buffered_async_serial.html#a4ac460f8b50222394dc0cf0fec47f159">00649</a> std::string <a class="code" href="class_buffered_async_serial.html#a4ac460f8b50222394dc0cf0fec47f159">BufferedAsyncSerial::readString</a>()
<a name="l00650"></a>00650 {
<a name="l00651"></a>00651     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00652"></a>00652     <span class="keywordtype">string</span> result(readQueue.begin(),readQueue.end());
<a name="l00653"></a>00653     readQueue.clear();
<a name="l00654"></a>00654     <span class="keywordflow">return</span> result;
<a name="l00655"></a>00655 }
<a name="l00656"></a>00656 
<a name="l00657"></a><a class="code" href="class_buffered_async_serial.html#a1977bd9ded2ae1ab084f2ccb27e6511e">00657</a> std::string <a class="code" href="class_buffered_async_serial.html#a1977bd9ded2ae1ab084f2ccb27e6511e">BufferedAsyncSerial::readStringUntil</a>(<span class="keyword">const</span> std::string delim)
<a name="l00658"></a>00658 {
<a name="l00659"></a>00659     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00660"></a>00660     vector&lt;char&gt;::iterator it=findStringInVector(readQueue,delim);
<a name="l00661"></a>00661     <span class="keywordflow">if</span> (it==readQueue.end()) <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;
<a name="l00662"></a>00662     <span class="keywordtype">string</span> result(readQueue.begin(),it);
<a name="l00663"></a>00663     it+=delim.size();<span class="comment">//Do remove the delimiter from the queue</span>
<a name="l00664"></a>00664     readQueue.erase(readQueue.begin(),it);
<a name="l00665"></a>00665     <span class="keywordflow">return</span> result;
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 <span class="keywordtype">void</span> BufferedAsyncSerial::readCallback(<span class="keyword">const</span> <span class="keywordtype">char</span> *data, <span class="keywordtype">size_t</span> len)
<a name="l00669"></a>00669 {
<a name="l00670"></a>00670     lock_guard&lt;mutex&gt; l(readQueueMutex);
<a name="l00671"></a>00671     readQueue.insert(readQueue.end(),data,data+len);
<a name="l00672"></a>00672 }
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 std::vector&lt;char&gt;::iterator BufferedAsyncSerial::findStringInVector(
<a name="l00675"></a>00675     std::vector&lt;char&gt;&amp; v,<span class="keyword">const</span> std::string&amp; s)
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677     <span class="keywordflow">if</span> (s.size()==0) <span class="keywordflow">return</span> v.end();
<a name="l00678"></a>00678 
<a name="l00679"></a>00679     vector&lt;char&gt;::iterator it=v.begin();
<a name="l00680"></a>00680     <span class="keywordflow">for</span> (;;)
<a name="l00681"></a>00681     {
<a name="l00682"></a>00682         vector&lt;char&gt;::iterator result=find(it,v.end(),s[0]);
<a name="l00683"></a>00683         <span class="keywordflow">if</span> (result==v.end()) <span class="keywordflow">return</span> v.end();<span class="comment">//If not found return</span>
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;s.size(); i++)
<a name="l00686"></a>00686         {
<a name="l00687"></a>00687             vector&lt;char&gt;::iterator temp=result+i;
<a name="l00688"></a>00688             <span class="keywordflow">if</span> (temp==v.end()) <span class="keywordflow">return</span> v.end();
<a name="l00689"></a>00689             <span class="keywordflow">if</span> (s[i]!=*temp) <span class="keywordflow">goto</span> mismatch;
<a name="l00690"></a>00690         }
<a name="l00691"></a>00691         <span class="comment">//Found</span>
<a name="l00692"></a>00692         <span class="keywordflow">return</span> result;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694 mismatch:
<a name="l00695"></a>00695         it=result+1;
<a name="l00696"></a>00696     }
<a name="l00697"></a>00697 }
<a name="l00698"></a>00698 
<a name="l00699"></a><a class="code" href="class_buffered_async_serial.html#a385796d6f383544cf253c15b66e4eb13">00699</a> <a class="code" href="class_buffered_async_serial.html#a385796d6f383544cf253c15b66e4eb13">BufferedAsyncSerial::~BufferedAsyncSerial</a>()
<a name="l00700"></a>00700 {
<a name="l00701"></a>00701     <a class="code" href="class_async_serial.html#a79c529d01fb7df3ed2ad5d771141f7a7">clearReadCallback</a>();
<a name="l00702"></a>00702 }
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Mar 9 2011 05:50:17 for mavsim by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
