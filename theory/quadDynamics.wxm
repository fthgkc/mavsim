/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 0.8.7 ] */

/* [wxMaxima: input   start ] */
batch("common.wxm");
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Nonlinear Measurement Equation
   [wxMaxima: section end   ] */

/* [wxMaxima: comment start ]
The inertia matrix J
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
J : matrix([Jx,-Jxy,-Jxz],[-Jxy,Jy,-Jyz],[-Jxz,-Jyz,Jz]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
v_cm_b : transpose([U,V,W]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
M_b_AT : genmatrix(M_b_AT,3,1);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
F_b_T : genmatrix(F_b_T,3,1);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
b_w_ib_b : invert(J).(M_b_AT - cross(w_ib,J.w_ib));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Checked against Aircraft Control and Simulation book 'Stevens and Lewis'  p.110
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
fullratsimp(subst([Jyz=0,Jxy=0],b_w_ib_b)[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
We now construct the state vector for the dynamcis in the stability axis.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
x : transpose([Vt, alpha, theta, wy, beta, phi, wx, wz]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Need: alpha, beta, Vt on page 115 Eqns 2.5-2.9 ; derive/check equations 
Need: Power ; model for the motors RESEARCH

The input will be expressed in terms of motor thrust ratios where delta_FB_LR represents Thrust(F + B) / Thrust(L +R)
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
u : transpose([delta_LR_FB,delta_Fsq_Bsq,delta_Lsq_Rsq, T_sumSq]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
When finding G we need to express dstate in terms of the input ratios and thrust sums. This means we need to substitute
all occurences of T_i with the ratios.
As a rough example The equation in the x direction should be:
   [wxMaxima: comment end   ] */

/* [wxMaxima: comment start ]
'Bond Graph Dynamic Modeling and Stabilization of a Quad-Rotor Helicopter'
 page 3 equations for Thrust vs Rpm
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
RPM(dutycyle,KV,batVolt) := dutycycle*KV*2*%pi/60*batVolt;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
ThrustFull(dutycycle) := rho/4*(RPM(dutycycle,KV,batVolt))^2*rBlade^3*
liftCurveSlope*nBlades*chord*(theta_tau-phi_tau);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Most of these are constants so we will substitute the constant terms as gamma.
Gamma = (chord*pi^2*rho*(theta_tau-phi_tau)*batVolt^2*KV^2*liftCurveSlope*nBlades*rBlade^3)/3600
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Thrust(dutycycle) := fullratsubst([(chord*%pi^2*rho*(theta_tau-phi_tau)*batVolt^2*KV^2*liftCurveSlope*nBlades*rBlade^3)/3600=GammaT],ThrustFull(dutycycle));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
GammaT(rho,theta_tau,phi_tau,batVolt,KV,liftCurveSlope,nBlades,rBlade) :=
(chord*%pi^2*rho*(theta_tau-phi_tau)*batVolt^2*KV^2*liftCurveSlope*nBlades*rBlade^3)/3600;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
http://www.aveox.com/DC.aspx  Equations for torque calculation in terms of RPM
I = Current 
Inl = No load current 
J = Torque (oz-in/A) 
Kb = Voltage constant (Volt/1000 RPM) 
Kt = Torque constant (oz-In/A) 
Pi = Power input (Watts)  
Rm = Terminal resistance 
RPM = Revolutions/minute 
V = Voltage

Torque constant: Kt=Kb x 1.345 
Current draw of motor: I = [V-(Kb x kRPM)]/Rm 
Torque output of motor: J = (Kt x I) - (Kt x Inl) 
RPM of motor: kRPM = (V - RmI) / Kb 
KV = 1000/Kb
Kb = 1000/KV
0.000968504759=1.345
J = (

CHeck current draw of motor equation.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Torque(dutycycle):= 0.968504759/KV*((batVolt*dutycycle)/Rm-Inl);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
T_L : Thrust(dutycycle_L);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
T_R : Thrust(dutycycle_R);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
T_F : Thrust(dutycycle_F);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
T_B : Thrust(dutycycle_B);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
t_L : Torque(dutycycle_L);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
t_R : Torque(dutycycle_R);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
t_F : Torque(dutycycle_F);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
t_B : Torque(dutycycle_B);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
M_b_AT_quad : fullratsubst([dutycycle_L^2-dutycycle_R^2=delta_Lsq_Rsq,
dutycycle_F^2-dutycycle_B^2=delta_Fsq_Bsq,
(dutycycle_R+dutycycle_L-dutycycle_F-dutycycle_B)=delta_LR_FB],
factor(expand(fullratsimp(
transpose([(T_L - T_R)*dm , (T_F-T_B)*dm, t_L+t_R-t_F-t_B])))));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Check these equaitons.
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Cl : 2*%pi*alpha;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Assuming an uncambered lifting surface ( the frame) we can estimate the drag polar as:
home.anadolu.edu.tr/~mcavcar/common/Aerodynamicforces.pdf
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Cd : Cd0 + K_cd_cl*Cl^2;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
NOTE: This is probably wrong
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
Cs : 2*%pi*beta;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
F_w_A : transpose([-Cd*.5*rho*Vt^2*s_frame,-Cs*.5*rho*Vt^2*s_frame_side,-Cl*.5*rho*Vt^2*s_frame]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
C_wb : C3(beta).C2(-alpha);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
F_w : C_wb.F_b_T + F_w_A + m*C_wb.C_bn_euler.g_n;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
v_rel_w : transpose([Vt,0,0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
dw_v_rel_w : transpose([d_Vt,0,0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
w_wb : transpose([0,0,d_beta]) + C3(beta).transpose([0,-d_alpha,0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
db_v_rel_w : dw_v_rel_w + cross(w_wb,v_rel_w);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
eqn_d_v_w(i) := m*db_v_rel_w[i,1] = F_w[i,1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
eq_d_Vt : rhs(solve(eqn_d_v_w(1),d_Vt)[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
eq_d_beta : rhs(solve(eqn_d_v_w(2),d_beta)[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
eq_d_alpha : rhs(solve(eqn_d_v_w(3),d_alpha)[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
d_x : transpose([eq_d_Vt,eq_d_alpha,d_theta,b_w_ib_b[2,1],eq_d_beta,d_phi,b_w_ib_b[1,1],b_w_ib_b[3,1]]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
quadAssumptions : [F_b_T[3,1]=-1*(T_F+T_B+T_L+T_R),F_b_T[2,1]=0,F_b_T[1,1]=0,
    Jxy=0,Jyz=0,Jxz=0,dutycycle_F^2+dutycycle_B^2+dutycycle_L^2+dutycycle_R^2=T_sumSq,
dutycycle_L+dutycycle_R-dutycyle_F-dutycycle_B=delta_LR_FB,
dutycycle_L^2-dutycycle_R^2=delta_Lsq_Rsq,
dutycycle_F^2-dutycycle_B^2=delta_Fsq_Bsq,
M_b_AT[1,1]=M_b_AT_quad[1,1],M_b_AT[2,1]=M_b_AT_quad[2,1],M_b_AT[3,1]=M_b_AT_quad[3,1]];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
d_x_quad : fullratsimp(trigsimp(fullratsubst(quadAssumptions,d_x)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
d_x_quad_trim_eq : subst([phi=0,beta=0,wx=0,wy=0,wz=0,alpha=theta],d_x_quad);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
T_sumSq_trim : rhs(solve(d_x_quad_trim_eq[1,1],T_sumSq)[1]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
theta_sol:trigsimp(subst([T_sumSq=T_sumSq_trim],d_x_quad_trim_eq[2,1]));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
theta_sol_num:ratnumer(theta_sol);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
K was calculated by K=1/pi/AR/e where e (Oswald efficiency factor) is assumed to be 0.7 
Cd0 was assumed to be the value of Cd0 of a cube. 
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
forward_constants : [GammaT=GammaT(rho,theta_tau,phi_tau,batVolt,KV,liftCurveSlope,nBlades,rBlade),
Vt=2,alpha=theta,K_cd_cl=.45,rho=1.225,Cd0=1.05,s_frame=.5,s_frame_side=0.05,gamma=0,
g=9.81,T_sumSq=2,m=1,Jx=1,Jy=1,Jz=1,KV=850,batVolt=11.1,Rm=350,dm=.5,theta_tau=10*%pi/180,
phi_tau=0,nBlades=2,rBlade=0.125,liftCurveSlope=2*%pi,chord=0.025];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
eq1 : expand(subst(forward_constants,[theta_sol_num]))[1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
plot2d(subst([theta=deg*%pi/180],eq1),[deg,-20,0]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
float(fullratsimp(subst([theta=-10*%pi/180,rho=1.225,s_frame=.5,K_cd_cl=0.45,Cd0=1.05,Vt=2,g=9.81,m=1],T_sumSq_trim)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
solve([theta_sol_num=0],[theta]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
solve([theta_sol],[theta]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
d_x_quad_trim_eq[2,1];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Linearization of Dynamics
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
F_quad : jacobian(makelist(d_x_quad[i,1],i,length(d_x_quad)),
makelist(x[i,1],i,1,length(x)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
Assuming that the quad is symmetric about the x and y axis this simplifies to:
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
G_quad : jacobian(makelist(d_x_quad[i,1],i,length(d_x_quad)),makelist(u[i,1],i,1,length(u)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
trimAssumptions : [wx=0,wy=0,wz=0,beta=0,phi=0,alpha=theta];
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
F_quad_trim : fullratsimp(subst([beta=0,phi=0,wx=0,wy=0,wz=0,theta-alpha=gamma],trigsimp(trigreduce(F_quad))));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
G_quad_trim : fullratsubst(trimAssumptions,trigsimp(trigreduce(G_quad)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
quad_forward_F : float(subst(theta=-9.8*%pi/180,subst(forward_constants,F_quad_trim)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
quad_forward_G : float(subst(theta=-9.8*%pi/180,subst(forward_constants,G_quad_trim)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: comment start ]
We can't observe alpha or beta
   [wxMaxima: comment end   ] */

/* [wxMaxima: input   start ] */
z_quad : transpose([x[1,1],x[3,1],x[4,1],x[6,1],x[7,1],x[8,1]]);
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
u;
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
quad_C : jacobian(makelist(z_quad[i,1],i,1,length(z_quad)),makelist(x[i,1],i,1,length(x)));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: section start ]
Fortran Output
   [wxMaxima: section end   ] */

/* [wxMaxima: input   start ] */
with_stdout ("code/quad_forward_F.f90", f90(quad_forward_F));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
with_stdout ("code/quad_forward_G.f90", f90(quad_forward_G));
/* [wxMaxima: input   end   ] */

/* [wxMaxima: input   start ] */
with_stdout ("code/quad_C.f90", f90(quad_C));
/* [wxMaxima: input   end   ] */

/* Maxima can't load/batch files which end with a comment! */
"Created with wxMaxima"$
